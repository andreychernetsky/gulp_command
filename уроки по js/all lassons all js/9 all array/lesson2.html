<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>Document</title>
</head>
<body>
<script>
  /*Массивы oldArray и newArray будут состоять из одних и тех же элементов, но фактически это будут разные объекты.
 
	 Важно запомнить, что если массив состоит из сущностей Array или Object, то они по прежнему будут ссылаться на родительские объекты.
 function */
  /*
		
		const  someArray = [1,2,3];
		const newArray = someArray;
		someArray.push(4);
		console.log(someArray);//[1,2,3,4]
		console.log(newArray);//[1,2,3,4]*/

  /* Почему нельзя просто присмоить одному массиву другой?
		 Дело в том, что в JavaScript массив является объектом, и поэтому мы не скопируем его, а просто создадим ссылку на существующий. В результате, при внесении изминений в любой из них, второй тоже будет изменен, потому что это один и тот же массив.*/
  // корректный пример

  /*Осторожно с этим методом (slice)!
    При многомерном массиве вы получите новый(!) массив, но внутри он будет содержать ссылки на вложенные массивы из старого массива.*/

  const  someArray = [1,2,3];
  const newArray = someArray.slice();
  someArray.push(4);
  console.log(someArray);//[1,2,3,4]
  console.log(newArray);//[1,2,3]*/


  function dubleCopyArr() {
    let oldArray = ["a","b","c"];
    let newArray = oldArray.slice();

    return newArray;
  }
  console.log(dubleCopyArr());//["a","b","c"]

  //  Методы массивов

  let arr = ['1','go','home'];
  delete arr[1];
  console.log(arr);//['1',,'home']
  console.log(arr.length);//3

  let arr = ['1','go','home'];
  arr.splice(1,1);
  console.log(arr);//['1','home']
  console.log(arr.length);//2

  let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
  arr.splice(0,3);
  console.log(arr);//["прямо", "сейчас"]


  let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
  arr.splice(0,3, "давайте танцевать");
  console.log(arr);//["давайте танцевать", "прямо", "сейчас"]

  // example
  let arr = [1, 2, 5];

  // начиная с индекса -1 (перед последним элементом)
  // удалить 0 элементов,
  // затем вставить числа 3 и 4
  arr.splice(-1,0,3,4);
  console.log(arr);//[1,2,3,4,5]


  //  Метод arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.

  let arr =[1,2];
  let arrayLike = {
    0:"что-то",
    length:1
  };

  console.log(arr.concat(arrayLike));//[1,2,{0:'что-то', length:1}]

  //example

  let arr =[1,2];
  let arrayLike = {
    0:"что-то",
    1:"еще",
    [Symbol.isConcatSpreadable]:true,length:2
  };

  console.log(arr.concat(arrayLike));//[1,2,'то-то',' еще']

  /*Методы arr.indexOf, arr.lastIndexOf и arr.includes имеют одинаковый синтаксис и делают по сути то же самое, что и их строковые аналоги, но работают с элементами вместо символов:
  
  Чтобы определить расположение элемента в массиве, можно воспользоваться методом indexOf(). Он возвращает индекс первого вхождения элемента, либо -1, если он не найден.

	arr.indexOf(item, from) ищет item, начиная с индекса from, и возвращает индекс, на котором был найден искомый элемент, в противном случае -1.
arr.lastIndexOf(item, from) – то же самое, но ищет справа налево.
arr.includes(item, from) – ищет item, начиная с индекса from, и возвращает true, если поиск успешен.*/


  /*
	let str = 'Я учу учу Javascript';
	console.log(str.indexOf('учу'))//2
	*/

  // example
  /*let str = 'Я учу Javascript';
	console.log(str.indexOf('PHP', 5));//-1*/

  let str = 'Я учу Javascript';
  console.log(str.indexOf('JaVaScrIpt'));//-1

  // example
  //  Поиск осуществляется слева направо. Метод чувствителен к регистру символов.


  "Привет, мир".indexOf("Привет");    // вернет 0

  "Привет, мир".indexOf("Корова");    // вернет -1

  "Привет, мир".indexOf("мир");    // вернет 8

  "Привет, мир".indexOf("Мир"); // вернет -1

  // Пример: с позицией

  "Привет, мир".indexOf("Привет", 0);    // вернет 0
  "Привет, мир".indexOf("р", 1);    // вернет 1
  "Привет, мир".indexOf("р", 5);   // вернет 10

  // Пустая подстрока находится в любом случае:

  // Пример: для пустой подстроки

  "Привет, мир".indexOf("", 5);    // вернет 5
  "Привет, мир".indexOf("", 7);    // вернет 7
  "Привет, мир".indexOf("", 999);    // вернет 11 (длину)

  exampleText()/*
const scores = [10, 20, 30, 10, 40, 20];
console.log(scores.indexOf(10)); // 0
console.log(scores.indexOf(30)); // 2
console.log(scores.indexOf(50)); // -1
console.log(scores.indexOf(20)); // 1*/


  // example
  /*Следующие выражение возвращает -1, даже если у первого элемента массива guests и searchElement будут одинаковые значения свойств name и age. Так как это два разных объекта:*/
  /*
	const guests = [
		{name: 'John Doe', age: 30},
		{name: 'Lily Bush', age: 20},
		{name: 'William Gate', age: 25}
	];
	
	console.log(guests.indexOf({
		name: 'John Doe',
		age: 30
	})); // -1
	*/

  // example
  /*В следующем примере функция find() используется для возврата массива с позициями числа 10 в массиве scores:*/

  /*
	function find(needle, haystack) {
		var results = [];
		var idx = haystack.indexOf(needle);
		while (idx != -1) {
			results.push(idx);
			idx = haystack.indexOf(needle, idx + 1);
		}
		return results;
	}
	console.log(find(10,scores)); // [0, 3]
	*/

  let users = [
    {id:1,name:"Вася"},
    {id:2,name:"петя"},
    {id:3,name:"Маша"},
  ];

  let user = users.find(item => item.id == 1);
  console.log(user.name)//вася


  //	filter
  /* На тот случай, если найденных элементов может быть много, предусмотрен метод arr.filter(fn).
		 Синтаксис этого метода схож с find, но filter возвращает массив из всех подходящих элементов:*/

  let users = [
    {id:1,name:"Вася"},
    {id:2,name:"петя"},
    {id:3,name:"Маша"},
  ];

  let someUsers = users.filter(item => item.id < 3);

  console.log(someUsers.length);//2


  //	map
  /* Метод arr.map является одним из наиболее полезных и часто используемых.
		 Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.*/

  let arr = [1,2,3];
  let result = arr.map((item,index,array)=>{
    return item += item;
    // возвращается новое значение вместо элемента
  });
  console.log(result);//[2,4,6]

  //	example
  'use strict';

  let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item=>item.length);
  console.log(lengths);//[5,7,6]
</script>
</body>
</html>